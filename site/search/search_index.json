{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions Solutions and comments to Part1 Solutions and comments to Part2 Solutions and comments to Part3","title":"Solutions"},{"location":"#solutions","text":"Solutions and comments to Part1 Solutions and comments to Part2 Solutions and comments to Part3","title":"Solutions"},{"location":"part1/","text":"Part 1 1. Word count Write a function that counts words in text and returns a dictionary which maps the word to the count number (int) of that word It should convert words to lower case Words should not have newlines Words should not contain separation characters like \", . ? !\" Suggested solutions: First we need to split the text into a list of words that we can loop over e.g. >>> text = 'She loves me, yeah yeah yeah!' >>> text.split() ['She', 'loves', 'me,', 'yeah', 'yeah', 'yeah!'] >>> Within the loop we would have to remove non-letter characters and convert to lower case, e.g. with strip and lower string methods >>> 'She'.lower() 'she' >>> 'yeah!'.strip('!') 'yeah' >>> >>> for w in text.split(): ... word = w.strip(',').strip('!').lower() >>> and finally put those words in a dictionary. What we first need then is to start out with an empty dictionary >>> d = {} >>> and within the loop there are a couple of approaches to fill the dictionary with values. A first valid attempt is to check if a word is already in the dictionary and then increase the value by 1, otherwise if it is absent insert the new word with value 1 >>> if word in d: ... d[word] += 1 ... else: ... d[word] = 1 >>> an alternative is to use the get method of a dictionary. That returns a default value for a key if it does not exist, otherwise. So we could have get return a 0 for words that are not yet in the dictionary >>> d = {} >>> for word in text.split(): ... d[word] = d.get(word, 0) + 1 >>> A third way is the collections module of the standard library which contains many useful tools. defaultdict is a class which is like a dictionary expects that it creates an entry when you reference something that is not there >>> import collections >>> d = collections.defaultdict(int) >>> d['new key'] 0 >>> d == {'new key': 0} True >>> A complete solution with the second version is >>> def word_count(text): ... \"\"\" ... Calculates words in text, return type: dict ... ... >>> word_count('bye bye') ... {'bye': 2} ... >>> word_count('She loves me yeah yeah yeah') ... {'she': 1, 'loves': 1, 'me': 1, 'yeah': 3} ... \"\"\" ... d = {} ... for w in text.split(): ... word = w.strip(',').strip('!').strip('?').lower() ... d[word] = d.get(word, 0) + 1 ... return d Satisfying >>> word_count('bye bye') == {'bye': 2} True >>> word_count('She loves me yeah yeah yeah') {'she': 1, 'loves': 1, 'me': 1, 'yeah': 3} >>> word_count(\"What?\") {'what': 1} >>> word_count(''' ... A word, ... if you please! ... ''') {'a': 1, 'word': 1, 'if': 1, 'you': 1, 'please': 1} 2. Pirate language translator Double any consonant and put an o in between >>> to_pirate('hello') # doctest: +SKIP hohelollolo The output should preserve leading upper case of the characters in the beginning of the sentance. See the tests below Solution We have to find a way of knowing when a character in a sequence is a consonant or not. The most obvious way is a list all known consonants and check if a character is member. That is perfectly valid. Here we get a shorter list of vowels to start with, and one can check if it is not one of those, but a list of non-consonants would have to be extended with spaces and other separation characters >>> VOWELS = 'eiyaou' >>> def to_pirate(text): ... pirate = \"\" ... nonconsonants = VOWELS + ' .,!?' ... for c in text: ... pirate += c ... if c.lower() not in nonconsonants: ... pirate += 'o' + c.lower() ... return pirate >>> assert to_pirate('hello') == 'hohelollolo' >>> assert to_pirate('Hello there') == 'Hohelollolo tothoherore' Even for a small function like this it is good practise to split up the logic into separate smaller functions if possible to get more readable code >>> VOWELS = 'eiyaou' >>> def to_pirate(text): ... pirate = \"\" ... for c in text: ... pirate += c ... if is_consonant(c): ... pirate += 'o' + c.lower() ... return pirate >>> def is_consonant(char): ... return char.lower() in 'bcdfghjklmnpqrstvwxz' >>> to_pirate('Hello there') 'Hohelollolo tothoherore' >>> assert to_pirate('hello') == 'hohelollolo' >>> assert to_pirate('Hello there') == 'Hohelollolo tothoherore' Note: in English the letter y is sometimes considered a consonant, but that does not affect test tests here.","title":"Part 1"},{"location":"part1/#part-1","text":"","title":"Part 1"},{"location":"part1/#1-word-count","text":"Write a function that counts words in text and returns a dictionary which maps the word to the count number (int) of that word It should convert words to lower case Words should not have newlines Words should not contain separation characters like \", . ? !\"","title":"1. Word count"},{"location":"part1/#suggested-solutions","text":"First we need to split the text into a list of words that we can loop over e.g. >>> text = 'She loves me, yeah yeah yeah!' >>> text.split() ['She', 'loves', 'me,', 'yeah', 'yeah', 'yeah!'] >>> Within the loop we would have to remove non-letter characters and convert to lower case, e.g. with strip and lower string methods >>> 'She'.lower() 'she' >>> 'yeah!'.strip('!') 'yeah' >>> >>> for w in text.split(): ... word = w.strip(',').strip('!').lower() >>> and finally put those words in a dictionary. What we first need then is to start out with an empty dictionary >>> d = {} >>> and within the loop there are a couple of approaches to fill the dictionary with values. A first valid attempt is to check if a word is already in the dictionary and then increase the value by 1, otherwise if it is absent insert the new word with value 1 >>> if word in d: ... d[word] += 1 ... else: ... d[word] = 1 >>> an alternative is to use the get method of a dictionary. That returns a default value for a key if it does not exist, otherwise. So we could have get return a 0 for words that are not yet in the dictionary >>> d = {} >>> for word in text.split(): ... d[word] = d.get(word, 0) + 1 >>> A third way is the collections module of the standard library which contains many useful tools. defaultdict is a class which is like a dictionary expects that it creates an entry when you reference something that is not there >>> import collections >>> d = collections.defaultdict(int) >>> d['new key'] 0 >>> d == {'new key': 0} True >>> A complete solution with the second version is >>> def word_count(text): ... \"\"\" ... Calculates words in text, return type: dict ... ... >>> word_count('bye bye') ... {'bye': 2} ... >>> word_count('She loves me yeah yeah yeah') ... {'she': 1, 'loves': 1, 'me': 1, 'yeah': 3} ... \"\"\" ... d = {} ... for w in text.split(): ... word = w.strip(',').strip('!').strip('?').lower() ... d[word] = d.get(word, 0) + 1 ... return d Satisfying >>> word_count('bye bye') == {'bye': 2} True >>> word_count('She loves me yeah yeah yeah') {'she': 1, 'loves': 1, 'me': 1, 'yeah': 3} >>> word_count(\"What?\") {'what': 1} >>> word_count(''' ... A word, ... if you please! ... ''') {'a': 1, 'word': 1, 'if': 1, 'you': 1, 'please': 1}","title":"Suggested solutions:"},{"location":"part1/#2-pirate-language-translator","text":"Double any consonant and put an o in between >>> to_pirate('hello') # doctest: +SKIP hohelollolo The output should preserve leading upper case of the characters in the beginning of the sentance. See the tests below","title":"2. Pirate language translator"},{"location":"part1/#solution","text":"We have to find a way of knowing when a character in a sequence is a consonant or not. The most obvious way is a list all known consonants and check if a character is member. That is perfectly valid. Here we get a shorter list of vowels to start with, and one can check if it is not one of those, but a list of non-consonants would have to be extended with spaces and other separation characters >>> VOWELS = 'eiyaou' >>> def to_pirate(text): ... pirate = \"\" ... nonconsonants = VOWELS + ' .,!?' ... for c in text: ... pirate += c ... if c.lower() not in nonconsonants: ... pirate += 'o' + c.lower() ... return pirate >>> assert to_pirate('hello') == 'hohelollolo' >>> assert to_pirate('Hello there') == 'Hohelollolo tothoherore' Even for a small function like this it is good practise to split up the logic into separate smaller functions if possible to get more readable code >>> VOWELS = 'eiyaou' >>> def to_pirate(text): ... pirate = \"\" ... for c in text: ... pirate += c ... if is_consonant(c): ... pirate += 'o' + c.lower() ... return pirate >>> def is_consonant(char): ... return char.lower() in 'bcdfghjklmnpqrstvwxz' >>> to_pirate('Hello there') 'Hohelollolo tothoherore' >>> assert to_pirate('hello') == 'hohelollolo' >>> assert to_pirate('Hello there') == 'Hohelollolo tothoherore' Note: in English the letter y is sometimes considered a consonant, but that does not affect test tests here.","title":"Solution"},{"location":"part2/","text":"Part 2 1. Classes Define a class Circle that stores position in the x-y plane and its radius >>> from pytest import approx >>> from math import pi >>> class Circle: ... ... Let the default behaviour be a unit circle centered around origo When we supply arguments to the class constructor the circle shape and position is saved Default behaviour means here to provide non-required (keyword) parameters to the constructor function __init__ . If we have x , y for the center of a circle and r for its radius def __init__(self, x=0.0, y=0.0, r=1.0): self.x = x self.y = y self.r = r Add class methods for calculating the area and circumference Given that these value are saved for a circle object the functions for area and circumference are straightforward def area(self): return pi*self.r**2 def circumference(self): return 2*pi*self.r Define an overloading method such that we can compare two Circle objects, being equal if they have same radius and center. Use any comparison between floats with the pytest approx function Equality between two Python objects has to be defined in the class, if it is supposed to mean anything different from object identity. e.g. >>> class Foo: ... pass >>> Foo() == Foo() False returns False just because we have two different objects. To define equality for a class, the == operator is implemented by the __eq__ method If we define two Circle objects to be equal when they have the same center and radius we could implement, allowing for round-off errors that we have with float operations def __eq__(self, other): return self.x == approx(other.x) and self.y == approx(other.y) and self.r == approx(other.r) Then a total solution is >>> class Circle: ... ### BEGIN SOLUTION ... def __init__(self, x=0.0, y=0.0, r=1.0): ... self.x = x ... self.y = y ... self.r = r ... ... def area(self): ... return pi*self.r**2 ... ... def circumference(self): ... return 2*pi*self.r ... ... def __eq__(self, other): ... return self.x == approx(other.x) and self.y == approx(other.y) and self.r == approx(other.r) satisfying tests >>> circ = Circle() >>> assert circ.x == approx(0.0) >>> assert circ.y == approx(0.0) >>> assert circ.r == approx(1.0) >>> circ = Circle(r=2) >>> assert circ.x == approx(0.0) >>> assert circ.y == approx(0.0) >>> assert circ.r == approx(2.0) >>> >>> circ = Circle(x=1, y=1) >>> assert circ.x == approx(1.0) >>> assert circ.y == approx(1.0) >>> assert circ.r == approx(1.0) >>> assert Circle().area() == approx(pi) >>> assert Circle().circumference() == approx(2*pi) >>> assert Circle(r=2).area() == approx(4*pi) >>> assert Circle(r=3).circumference() == approx(6*pi) >>> circ_a = Circle(x=1, y=2, r=3) >>> circ_b = Circle(x=1, y=2, r=3) >>> assert circ_a == circ_b","title":"Part 2"},{"location":"part2/#part-2","text":"","title":"Part 2"},{"location":"part2/#1-classes","text":"Define a class Circle that stores position in the x-y plane and its radius >>> from pytest import approx >>> from math import pi >>> class Circle: ... ... Let the default behaviour be a unit circle centered around origo When we supply arguments to the class constructor the circle shape and position is saved Default behaviour means here to provide non-required (keyword) parameters to the constructor function __init__ . If we have x , y for the center of a circle and r for its radius def __init__(self, x=0.0, y=0.0, r=1.0): self.x = x self.y = y self.r = r Add class methods for calculating the area and circumference Given that these value are saved for a circle object the functions for area and circumference are straightforward def area(self): return pi*self.r**2 def circumference(self): return 2*pi*self.r Define an overloading method such that we can compare two Circle objects, being equal if they have same radius and center. Use any comparison between floats with the pytest approx function Equality between two Python objects has to be defined in the class, if it is supposed to mean anything different from object identity. e.g. >>> class Foo: ... pass >>> Foo() == Foo() False returns False just because we have two different objects. To define equality for a class, the == operator is implemented by the __eq__ method If we define two Circle objects to be equal when they have the same center and radius we could implement, allowing for round-off errors that we have with float operations def __eq__(self, other): return self.x == approx(other.x) and self.y == approx(other.y) and self.r == approx(other.r) Then a total solution is >>> class Circle: ... ### BEGIN SOLUTION ... def __init__(self, x=0.0, y=0.0, r=1.0): ... self.x = x ... self.y = y ... self.r = r ... ... def area(self): ... return pi*self.r**2 ... ... def circumference(self): ... return 2*pi*self.r ... ... def __eq__(self, other): ... return self.x == approx(other.x) and self.y == approx(other.y) and self.r == approx(other.r) satisfying tests >>> circ = Circle() >>> assert circ.x == approx(0.0) >>> assert circ.y == approx(0.0) >>> assert circ.r == approx(1.0) >>> circ = Circle(r=2) >>> assert circ.x == approx(0.0) >>> assert circ.y == approx(0.0) >>> assert circ.r == approx(2.0) >>> >>> circ = Circle(x=1, y=1) >>> assert circ.x == approx(1.0) >>> assert circ.y == approx(1.0) >>> assert circ.r == approx(1.0) >>> assert Circle().area() == approx(pi) >>> assert Circle().circumference() == approx(2*pi) >>> assert Circle(r=2).area() == approx(4*pi) >>> assert Circle(r=3).circumference() == approx(6*pi) >>> circ_a = Circle(x=1, y=2, r=3) >>> circ_b = Circle(x=1, y=2, r=3) >>> assert circ_a == circ_b","title":"1. Classes"},{"location":"part3/","text":"Part 3 1. Decorator Consider a mathematical function of a variable $f(x)$. The derivative of the function is a measure of change, illustrated by the slope of a tangent line at a point on the curve For example given $$ f(x) = x^2 $$ the derivative is $$ f'(x) = 2x $$ which means that at e.g. $x_0=3$ a tangent to the curve has slope $f'(3) = 2*3=6$ and has the equation for a straight line $$ y = f(x_0) + f'(x_0)(x-x_0)$$ import math import matplotlib.pyplot as plt import numpy as np def f(x): return x**2 def fp(x): return 2*x x = np.arange(0, 5, .1) x0 = 3.0 plt.plot(x, f(x)) plt.plot(x, f(x0) + fp(x0)*(x-x0)) [<matplotlib.lines.Line2D at 0x7f97d37c4d30>] Mathematically derivatives are understood as the ratio of differences in y and x values close to a given point and taking the limit where the point get closer $$ f'(x) \\approx \\frac{f(x + \\delta) - f(x-\\delta)}{2\\delta} $$ For a small number $\\delta$ this can be used as an approximation to the derivate for a function delta = 0.1 plt.vlines(x0-delta, 0, f(x0-delta), linestyle='dashed') plt.vlines(x0+delta, 0, f(x0+delta), linestyle='dashed') plt.hlines(f(x0-delta), 0, x0-delta, linestyle='dashed') plt.hlines(f(x0+delta), 0, x0+delta, linestyle='dashed') plt.text(2.9, -1, '$2\\delta$') plt.text(0, 10, '$f(3 + \\delta)$') plt.text(0, 7, '$f(3 -\\delta)$') plt.plot(x, f(x)) #plt.plot(dx, f(dx)) [<matplotlib.lines.Line2D at 0x7f97d378fb50>] Task Write a decorator that implements the numerical approximattion to a derivative The decorator applied to a library function, e.g. math.sin should then return a function for which approximately derivative(math.sin)(x) \u2248 math.cos(x) for most values of $x$ Likewise the decorator applied to a function definition with the @-syntax @derivative def f(x): return x**2 defines a function that satisfies f(x) \u2248 2*x for most values of $x$ Solution A Python decorator takes a function as input and returns a function as output. We accomplish this by defining an inner function that does the differentiation def wrap(x): return (f(x + delta) - f(x-delta))/(2*delta) A detail we may note here that x is a variable with some value that is input to the function. f and delta however are names that are not defined locally, Python tries to make sense of them by looking in the global context where the function is defined. If we would look closer at the function object defined as wrap we would find them in the __globals__ attribute of the function, a dictionary A full solution is then >>> delta = 1e-8 >>> def derivative(f): ... def wrap(x): ... return (f(x + delta) - f(x-delta))/(2*delta) ... return wrap which is verified by the tests epsilon = 1e-6 @derivative def f(x): return x**2 assert abs(f(3.0) - 6.0) < epsilon assert abs(derivative(math.sin)(.5) - math.cos(.5)) < epsilon assert abs(derivative(math.log)(3.0) - 1/3.0) < epsilon assert abs(derivative(math.exp)(1.0) - math.exp(1.0)) < epsilon assert abs(derivative(math.atan)(17.0) - 1/(1 + 17.0**2)) < epsilon 2. Generator This is a filter that returns lines of a file that have a length greader than maximum If the content of a textfile file.txt is hello you merry We except a function find_long_lines to behave like this >>> for line in find_long_lines('file.txt', 3): # doctest: +SKIP ... print(line) hello merry Knowing that the return value of the function must be iterable to use in a for-loop. Implement this function as a generator. The max_length should be without the final newline character \\n of the line Solution The generator is most easily defined as a function definition containing the yield statement When we loop over lines in a file, we get lines with a final newline character, which can be removed with the strip method for strings. >>> def find_long_lines(filename, max_length): ... for l in open(filename): ... line = l.strip() ... if len(line) > max_length: ... yield line %%file file.txt hello you merry >>> assert list(find_long_lines('file.txt', 3)) == ['hello', 'merry'] A final test that was not visible is to verify that the implementation was in fact a generator >>> from typing import Generator >>> assert isinstance(find_long_lines('foo', 7), Generator)","title":"Part 3"},{"location":"part3/#part-3","text":"","title":"Part 3"},{"location":"part3/#1-decorator","text":"Consider a mathematical function of a variable $f(x)$. The derivative of the function is a measure of change, illustrated by the slope of a tangent line at a point on the curve For example given $$ f(x) = x^2 $$ the derivative is $$ f'(x) = 2x $$ which means that at e.g. $x_0=3$ a tangent to the curve has slope $f'(3) = 2*3=6$ and has the equation for a straight line $$ y = f(x_0) + f'(x_0)(x-x_0)$$ import math import matplotlib.pyplot as plt import numpy as np def f(x): return x**2 def fp(x): return 2*x x = np.arange(0, 5, .1) x0 = 3.0 plt.plot(x, f(x)) plt.plot(x, f(x0) + fp(x0)*(x-x0)) [<matplotlib.lines.Line2D at 0x7f97d37c4d30>] Mathematically derivatives are understood as the ratio of differences in y and x values close to a given point and taking the limit where the point get closer $$ f'(x) \\approx \\frac{f(x + \\delta) - f(x-\\delta)}{2\\delta} $$ For a small number $\\delta$ this can be used as an approximation to the derivate for a function delta = 0.1 plt.vlines(x0-delta, 0, f(x0-delta), linestyle='dashed') plt.vlines(x0+delta, 0, f(x0+delta), linestyle='dashed') plt.hlines(f(x0-delta), 0, x0-delta, linestyle='dashed') plt.hlines(f(x0+delta), 0, x0+delta, linestyle='dashed') plt.text(2.9, -1, '$2\\delta$') plt.text(0, 10, '$f(3 + \\delta)$') plt.text(0, 7, '$f(3 -\\delta)$') plt.plot(x, f(x)) #plt.plot(dx, f(dx)) [<matplotlib.lines.Line2D at 0x7f97d378fb50>]","title":"1. Decorator"},{"location":"part3/#task","text":"Write a decorator that implements the numerical approximattion to a derivative The decorator applied to a library function, e.g. math.sin should then return a function for which approximately derivative(math.sin)(x) \u2248 math.cos(x) for most values of $x$ Likewise the decorator applied to a function definition with the @-syntax @derivative def f(x): return x**2 defines a function that satisfies f(x) \u2248 2*x for most values of $x$","title":"Task"},{"location":"part3/#solution","text":"A Python decorator takes a function as input and returns a function as output. We accomplish this by defining an inner function that does the differentiation def wrap(x): return (f(x + delta) - f(x-delta))/(2*delta) A detail we may note here that x is a variable with some value that is input to the function. f and delta however are names that are not defined locally, Python tries to make sense of them by looking in the global context where the function is defined. If we would look closer at the function object defined as wrap we would find them in the __globals__ attribute of the function, a dictionary A full solution is then >>> delta = 1e-8 >>> def derivative(f): ... def wrap(x): ... return (f(x + delta) - f(x-delta))/(2*delta) ... return wrap which is verified by the tests epsilon = 1e-6 @derivative def f(x): return x**2 assert abs(f(3.0) - 6.0) < epsilon assert abs(derivative(math.sin)(.5) - math.cos(.5)) < epsilon assert abs(derivative(math.log)(3.0) - 1/3.0) < epsilon assert abs(derivative(math.exp)(1.0) - math.exp(1.0)) < epsilon assert abs(derivative(math.atan)(17.0) - 1/(1 + 17.0**2)) < epsilon","title":"Solution"},{"location":"part3/#2-generator","text":"This is a filter that returns lines of a file that have a length greader than maximum If the content of a textfile file.txt is hello you merry We except a function find_long_lines to behave like this >>> for line in find_long_lines('file.txt', 3): # doctest: +SKIP ... print(line) hello merry Knowing that the return value of the function must be iterable to use in a for-loop. Implement this function as a generator. The max_length should be without the final newline character \\n of the line","title":"2. Generator"},{"location":"part3/#solution_1","text":"The generator is most easily defined as a function definition containing the yield statement When we loop over lines in a file, we get lines with a final newline character, which can be removed with the strip method for strings. >>> def find_long_lines(filename, max_length): ... for l in open(filename): ... line = l.strip() ... if len(line) > max_length: ... yield line %%file file.txt hello you merry >>> assert list(find_long_lines('file.txt', 3)) == ['hello', 'merry'] A final test that was not visible is to verify that the implementation was in fact a generator >>> from typing import Generator >>> assert isinstance(find_long_lines('foo', 7), Generator)","title":"Solution"}]}